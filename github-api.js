// github-api.js â€” Pure GitHub REST API wrapper (no cloning required)

const API = "https://api.github.com";
const REPO_NAME = "ghost-commits-repo";

/**
 * Standard headers for every GitHub API call.
 */
function headers(token) {
  return {
    Authorization: `Bearer ${token}`,
    Accept: "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",
  };
}

/**
 * Small fetch wrapper that throws on non-2xx.
 */
async function ghFetch(token, method, path, body = null) {
  const opts = { method, headers: headers(token) };
  if (body) opts.body = JSON.stringify(body);
  const res = await fetch(`${API}${path}`, opts);
  const data = await res.json().catch(() => null);
  if (!res.ok) {
    const msg = data?.message || res.statusText;
    const err = new Error(`GitHub ${method} ${path}: ${res.status} ${msg}`);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  return data;
}

// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Validate the token and return its scopes.
 * Classic PATs return scopes via X-OAuth-Scopes header.
 * Fine-grained PATs do NOT return that header, so scopes will be null.
 * Returns { user, scopes: string[] | null }
 */
export async function validateToken(token) {
  const res = await fetch(`${API}/user`, { headers: headers(token) });
  const data = await res.json().catch(() => null);
  if (!res.ok) {
    const msg = data?.message || res.statusText;
    const err = new Error(`GitHub GET /user: ${res.status} ${msg}`);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  const scopeHeader = res.headers.get("X-OAuth-Scopes");
  const scopes = scopeHeader
    ? scopeHeader.split(",").map((s) => s.trim()).filter(Boolean)
    : null;
  return { user: data, scopes };
}

/**
 * GET /user â€” returns { login, email, name, ... }
 */
export async function getAuthenticatedUser(token) {
  return ghFetch(token, "GET", "/user");
}

/**
 * Fetch the user's verified, primary email.
 * Falls back to /user .email if /user/emails is forbidden (classic PAT w/o user:email scope).
 */
export async function getUserEmail(token) {
  // 1. Best: use /user/emails (needs `user:email` scope on the PAT)
  try {
    const emails = await ghFetch(token, "GET", "/user/emails");
    const primary = emails.find((e) => e.primary && e.verified);
    if (primary) return primary.email;
    const verified = emails.find((e) => e.verified);
    if (verified) return verified.email;
  } catch {
    // PAT may lack the user:email scope â€” fall back.
  }

  // 2. Fallback: /user .email (null when email is set to private)
  const user = await getAuthenticatedUser(token);
  if (user.email) return user.email;

  // 3. Last resort: GitHub noreply address.
  //    Format: <id>+<login>@users.noreply.github.com
  //    This is always verified and counts toward the contribution graph.
  if (user.id && user.login) {
    return `${user.id}+${user.login}@users.noreply.github.com`;
  }

  return null;
}

/**
 * Create the private ghost-commits repo (idempotent).
 * Returns { owner, repo, html_url }.
 */
export async function createPrivateRepo(token) {
  try {
    const data = await ghFetch(token, "POST", "/user/repos", {
      name: REPO_NAME,
      private: true,
      auto_init: true, // creates initial commit so Git Data API works
      description:
        "ðŸŸ© Auto-generated by Ghost Commits â€” keeps your contribution graph green.",
    });
    return { owner: data.owner.login, repo: data.name, html_url: data.html_url };
  } catch (err) {
    if (err.status === 422) {
      // Repo already exists â€” fetch it instead.
      const user = await getAuthenticatedUser(token);
      const data = await ghFetch(
        token,
        "GET",
        `/repos/${user.login}/${REPO_NAME}`
      );
      return { owner: data.owner.login, repo: data.name, html_url: data.html_url };
    }
    throw err;
  }
}

/**
 * Get the SHA of the latest commit on the default branch (main).
 */
export async function getLatestCommitSha(token, owner, repo, branch = "main") {
  const data = await ghFetch(
    token,
    "GET",
    `/repos/${owner}/${repo}/git/ref/heads/${branch}`
  );
  return data.object.sha;
}

/**
 * Create a single ghost commit via the Git Data API.
 *
 * Flow: create blob â†’ create tree â†’ create commit â†’ update ref
 *
 * Each commit appends a timestamped line to `ghost.txt` so there is a real diff.
 */
export async function createGhostCommit(
  token,
  owner,
  repo,
  email,
  authorName,
  commitDate = null
) {
  const branch = "main";
  const now = commitDate ? new Date(commitDate) : new Date();
  const isoDate = now.toISOString();

  // 1. Get current commit + its tree
  const parentSha = await getLatestCommitSha(token, owner, repo, branch);
  const parentCommit = await ghFetch(
    token,
    "GET",
    `/repos/${owner}/${repo}/git/commits/${parentSha}`
  );
  const baseTreeSha = parentCommit.tree.sha;

  // 2. Create a blob (the file content)
  //    Include a random nonce so rapid commits always produce a unique diff.
  const nonce = Math.random().toString(36).slice(2, 10);
  const content = `ghost commit @ ${isoDate} [${nonce}]\n`;
  const blob = await ghFetch(
    token,
    "POST",
    `/repos/${owner}/${repo}/git/blobs`,
    { content, encoding: "utf-8" }
  );

  // 3. Create a tree that adds/appends to ghost.txt
  const tree = await ghFetch(
    token,
    "POST",
    `/repos/${owner}/${repo}/git/trees`,
    {
      base_tree: baseTreeSha,
      tree: [
        {
          path: "ghost.txt",
          mode: "100644",
          type: "blob",
          sha: blob.sha,
        },
      ],
    }
  );

  // 4. Create the commit
  const commit = await ghFetch(
    token,
    "POST",
    `/repos/${owner}/${repo}/git/commits`,
    {
      message: `ðŸ‘» ghost commit â€” ${isoDate}`,
      tree: tree.sha,
      parents: [parentSha],
      author: {
        name: authorName || "Ghost Commits",
        email: email,
        date: isoDate,
      },
    }
  );

  // 5. Update the branch ref (force: true avoids 422 on rapid sequential commits)
  await ghFetch(
    token,
    "PATCH",
    `/repos/${owner}/${repo}/git/refs/heads/${branch}`,
    { sha: commit.sha, force: true }
  );

  return { sha: commit.sha, date: isoDate };
}
